# Warmup Framework JMH Configuration
# 
# Configuración optimizada para benchmarks de rendimiento
# Ajusta estos valores según el hardware disponible

# JVM Options para benchmark
vm.opt.Xmx = 2G
vm.opt.Xms = 1G
vm.opt.XX:+UseG1GC
vm.opt.XX:+UnlockExperimentalVMOptions
vm.opt.XX:+UseJVMCICompiler

# Warmup iterations
# Número de iteraciones de warmup antes de medir
bench.warmup.iterations = 5

# Warmup time
# Tiempo de cada iteración de warmup (en segundos)
bench.warmup.time = 1

# Measurement iterations  
# Número de iteraciones reales para medición
bench.measurement.iterations = 10

# Measurement time
# Tiempo de cada iteración de medición (en segundos)
bench.measurement.time = 2

# Fork count
# Número de veces que se ejecuta cada benchmark en un proceso JVM diferente
bench.fork.count = 1

# Threads
# Número de hilos concurrentes para los benchmarks
bench.threads = 1

# Timeout (en segundos)
# Tiempo máximo permitido para ejecutar cada benchmark
bench.timeout = 120

# Results format
# Formato de los resultados: JSON, CSV, etc.
bench.results.format = JSON

# Include patterns
# Qué benchmarks incluir en la ejecución
bench.include = .*Benchmark$

# Exclude patterns
# Qué benchmarks excluir de la ejecución
bench.exclude = 

# Failure mode
# Cómo manejar errores: FAIL_AT_END, FAIL_FAST, FAIL_THROW
bench.fail.mode = FAIL_AT_END

# GC analysis
# Habilitar análisis de garbage collection
bench.gc.analysis = false

# Verbose output
# Salida detallada durante la ejecución
bench.verbose = false

# Save results to file
bench.results.file = warmup-benchmark-results.json

# Profiler configuration
# Perfilador a usar (prof, gc, async)
# bench.profiler = perf
# bench.profiler = gc
# bench.profiler = stack

# Time unit
# Unidad de tiempo para resultados: ns, us, ms, s
bench.time.unit = micros

# Benchmark mode
# Modo de benchmark: Throughput, AverageTime, SampleTime, SingleShotTime
bench.mode = AverageTime

# Output time unit  
# Unidad de tiempo para mostrar resultados: ns, us, ms, s
bench.output.timeunit = MICROSECONDS